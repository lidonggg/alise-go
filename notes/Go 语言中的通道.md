## Go 语言中的通道

标签（空格分隔）： go

---

通道（channel）是 Go 语言中最具有特色的数据类型，我们可以利用通道在多个 goroutine 之间传递数据。

### 啥是通道？
通道类型是天然并发安全的，它是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

在多个 goroutine 并发中，我们可以通过原子函数和互斥锁保证对共享资源的安全性，消除竞争状态，但这样会比较影响性能。除此之外，我们还可以通过使用通道，在多个 goroutine 之间发送和接收共享的数据，达到数据同步的目的。这就像在两个 goroutine 之间架设的管道，一个 goroutine 可以往管道里面塞数据，另一个 goroutine 可以从这个管道里面取数据，就类似于我们所熟知的队列（从下文可以知道它是一个先进先出（FIFO）的队列）。

### 通道的使用
在声明并初始化一个通道的时候，我们需要用到 Go 语言内建的 make 函数，它需要接收的第一个参数代表了通道的具体类型的类型字面量，如下述代码所示：
```go
ch := make(chan int)
```
其中 chan 是表示通道类型的关键字，而 int 则说明了该通道的元素类型。

在初始化通道的时候，make 函数除了必须接收这样的类型字面量作为参数，还可以接收一个 int 类型的可选参数（值必须大于等于 0 ）用于表示通道的容量。所谓的通道的容量，就是指通道最多可以缓存多少个元素值。当不传第二个参数或第二个参数值为 0 的时候，此时的通道我们称为**无缓冲的通道**，否则称为**有缓冲的通道**。如下述代码所示：
```go
ch := make(chan int)	  // 无缓冲的通道
ch2 := make(chan int, 0)  // 无缓冲的通道
ch3 := make(chan int, 3)  // 有缓冲的通道
```

一个通道相当于一个先进先出（FIFO）的队列，通道中的各个元素都是严格地按照发送的顺序排列的，先被发送的元素值一定也是先被接收的。元素的接收和发送这个个操作的运算符都是 **<-** 。如下述代码所示：
```go
ch := make(chan int, 3)
ch <- 1   // 发送数值 1 给这个通道
ch <- 2   // 发送数值 2 给这个通道
ch <- 3   // 发送数值 3 给这个通道
x := <-ch // 从通道里读取值，并把读取的值赋值给 x 变量
fmt.Printf("The first value received from channel ch is %d\n", x)    // The first value received from channel ch is 1
y := <-ch // 从通道里读取值，并把读取的值赋值给 y 变量
fmt.Printf("The first value received from channel ch is %d\n", y)    // The second value received from channel ch is 2
```
以上代码只适合有缓冲通道，对于无缓冲通道，类似的做法会产生死锁（deadlock），如<span id="deadlock1">以下代码</span>所示：
```go
ch := make(chan int) // 无缓冲的通道
ch <- 2
fmt.Printf(<-ch)     // 产生 deadlock
```
原因就是无缓冲通道和有缓冲通道有着不同的数据传递方式。
### 无缓冲通道
无缓冲通道本身不存储信息，它只负责转手，有人传给它，它就必须要传给别人，如果只进行接收或者发送其中某一个操作，都会造成阻塞。对于[上述代码](#deadlock1)来说，只有一个 goroutine 即主 goroutine，第二行代码阻塞在传值，第三行代码阻塞在取值，因此主线程会一直卡主，系统一直在等待，所以会被判定为产生 deadlock 然后结束程序。

因此我们可以发现，无缓冲通道要求发送 goroutine 和接收 goroutine 必须同时准备好且是两个不同的协程。因此<span id="deadlockExtend1">以下代码</span>是不会发生死锁错误的：
```go
ch := make(chan int) // 无缓冲的通道
go func() {          // 新开辟一个协程
	ch <- 2
}()
fmt.Print(<-ch)      // 成功打印出 2
```

#### **死锁延伸1**
考虑下述代码：
```go
ch1 := make(chan int)
ch2 := make(chan int)
go func() {
	ch2 <- 2        // a
	ch1 <- 1        // b
}()

<-ch1
```
它会产生死锁吗？答案是肯定的，也就是说，依然会产生死锁。这段代码并不能保证是主线程的 <-ch1 先执行，还是子线程先执行。如果是主线程先执行，那么它会阻塞直到有其他的线程往 ch1 传值，然而如果子线程开始执行了，会首先执行 ch2 <- 2 这段代码，它同样会等待有其他协程去接收值，然而这里并没有，因此会阻塞在这里而发生 deadlock。如果是子线程先执行，那么会直接阻塞在 ch2 <- 2 语句而产生死锁。如果把上述代码 a,b 行调换位置，那么程序将会成功发送变量 ch1，不产生死锁但是 ch2 会一直阻塞下去然后程序终止运行

#### **死锁延伸2**
考虑如下代码：
```go
ch1 := make(chan int)
ch2 := make(chan int)
go func() {
	ch2 <- 2        // a
	ch1 <- 1        // b
}()

<-ch1
<-ch2
```
它的执行结果依然是死锁，还是会产生主协程和子协程相互等待的情况。但如果调换 a,b 处代码的位置，那么程序将会成功执行。

#### **死锁延伸3**
考虑如下代码：
```go
ch1 := make(chan int)
ch2 := make(chan int)
go func() {
	ch2 <- 2
	ch1 <- 1
}()
go func() {
	<-ch1
	<-ch2
}()
```
此时两个子协程之间会因为相互等待而发生死锁，但是不会影响主协程，所以程序不会报死锁错误。

#### **死锁延伸4**
考虑如下代码：
```go
ch := make(chan int, 2)
ch <- 1
ch <- 2
for c := range ch {
	fmt.Println(c)
}
```

输出结果为：
```go
1
2
fatal error: all goroutines are asleep - deadlock!
```
虽然这里的ch是带有缓冲的信道，但是容量只有两个，当两个输出完之后，可以简单的将此时的信道等价于无缓冲的信道。显然对于无缓冲的信道只是单纯的读取元素是会造成阻塞的，而且是在主协程，所以和最开始的死锁现场等价，故而会死锁。
### 有缓冲通道
考虑如下的应用场景：想获取服务端的一个数据，不过这个数据在三个镜像站点上都存在，这三个镜像分散在不同的地理位置，而我们的目的又是想最快的获取到数据，那么需要怎么做？

在这里我们可以定义一个容量为 3 的通道，然后同时发起 3 个并发的 goroutine 向这三个镜像获取数据，获取到的数据发送到通道中，然后直接返回接收到的第一条数据即可，代码如下所示：
```go
func mirroredQuery() string {
	responses := make(chan string, 3)
	go func() { responses <- request("asia.gopl.io") }()
	go func() { responses <- request("europe.gopl.io") }()
	go func() { responses <- request("americas.gopl.io") }()
	return <-responses
}
func request(hostname string) (response string) { /* ... */ }
```
### 单向通道
有时候我们可能会限制某个通道只能接收或者只能发送，这种情况我们称之为“单向通道”。定义单向通道我们只要在定义的时候带上 <- 即可：
```go
var send chan<- int     //只能发送，<- 操作符在 chan 后面
var receive <-chan int  //只能接收，<- 操作符在 chan 前面
```

### 通道的发送和接收操作的一些基本特性
- 对于同一个通道，发送操作之间是互斥的，接收操作之间是互斥的，同时对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。有一个细节需要注意，那就是元素值从外界进入通道时会被复制，也就是说进入通道的并不是接收操作符右边的那个元素值，而是它的副本。

- 发送操作和接收操作中对元素值的处理都是不可分割的。

- 发送操作在完全完成之前会被阻塞，接收操作也是如此。

以上三个特性都是为了保证通道的并发安全而存在的。

### 获取通道的容量和长度
```go
cap(ch)     // 容量
len(ch)     // 长度
```
### 通道的关闭
```go
close(ch)
```